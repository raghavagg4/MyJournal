{% macro render_journal_content(form, selected_entry) %}
{% from "journal/components/stars.html" import render_stars %}
{{ render_stars() }}
<div class="flex-1 flex flex-col h-screen w-full overflow-hidden p-6 relative" id="content-panel">
    <!-- Add Quill CSS -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <!-- Add Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* Custom styles to remove white boundary on Quill editor */
        #editor-container {
            border: none !important;
            overflow-y: auto;
            height: 100%;
        }
        .ql-toolbar.ql-snow {
            border: none !important;
            border-bottom: none !important;
            background: transparent;
            display: flex;
            justify-content: flex-end;
            width: 100%;
            padding-right: 20px !important;
            position: absolute;
            right: 0;
            z-index: 10;
        }
        .ql-container.ql-snow {
            border: none !important;
        }
        .ql-editor {
            padding: 12px 0;
            font-family: 'Montserrat', sans-serif !important;
            font-size: 1.25rem !important;
            line-height: 1.6 !important;
        }

        /* Perspective Bubble Styles */
        .perspective-bubble {
            background-color: #1a1a1a;
            border: 2px solid #C5A880;
            border-radius: 12px;
            padding: 16px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
            color: white;
            font-family: 'Montserrat', sans-serif;
        }

        .perspective-content {
            position: relative;
        }

        .perspective-text {
            color: white;
            font-size: 1.1rem;
            line-height: 1.5;
            margin-right: 20px;
        }

        .perspective-loading {
            color: #9ca3af;
            font-style: italic;
            padding: 8px 0;
        }

        .perspective-error {
            color: #ef4444;
            font-style: italic;
            padding: 8px 0;
        }

        .perspective-close {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #1a1a1a;
            color: white;
            border: 1px solid #C5A880;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .perspective-close:hover {
            background-color: #C5A880;
            color: #1a1a1a;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Style for toolbar size dropdown preview */
        .ql-snow .ql-picker.ql-header .ql-picker-item[data-value="true"]::before {
            font-size: 16px;
            content: "Big";
            font-weight: bold;
        }
        .ql-snow .ql-picker.ql-header .ql-picker-item[data-value="false"]::before {
            font-size: 14px;
            content: "Text";
        }
        .ql-snow .ql-picker.ql-header .ql-picker-label::before {
            content: "Size";
        }
        /* Completely rebuild the header dropdown styling */
        .ql-snow .ql-picker.ql-header {
            width: auto !important;
            margin-right: 0;
        }
        .ql-snow .ql-picker-label {
            width: auto !important;
            padding: 0 18px 0 0 !important;
        }
        /* Make dropdown menu smaller */
        .ql-snow .ql-picker.ql-header .ql-picker-options {
            width: 70px !important;
            padding: 2px !important;
        }

        .ql-snow .ql-picker.ql-header .ql-picker-item {
            padding: 3px 5px !important;
            font-size: 12px !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }
        /* Remove any extra selectors that might be causing issues */
        .ql-toolbar.ql-snow .ql-picker.ql-header {
            margin-right: 0 !important;
        }

        /* Consistent styling for title and content */
        .journal-title-input {
            font-family: 'Montserrat', sans-serif !important;
            font-size: 2rem !important;
            font-weight: 600 !important;
            line-height: 1.4 !important;
            padding: 1.5rem 0 !important;
            border: none !important;
            outline: none !important;
            background: transparent !important;
            margin-bottom: 1rem !important;
            transition: border-color 0.2s ease !important;
        }

        .journal-title-input.focused {
            border-bottom: 1px solid #FFFFFF !important; /* White border when focused */
        }

        .journal-title-input::placeholder {
            color: #9CA3AF !important;
            font-weight: 500 !important;
        }

        /* Ensure all text in Quill uses Montserrat */
        .ql-editor * {
            font-family: 'Montserrat', sans-serif !important;
        }

        /* Style for placeholder text */
        .ql-editor.ql-blank::before {
            color: #9CA3AF !important;
            font-style: normal !important;
            left: 0 !important;
            right: auto !important;
        }
    </style>

    <div class="flex-1 w-full h-full">
        <div class="h-full w-full flex flex-col max-w-4xl mx-auto journal-content-wrapper">
            <form method="POST" action="{% if selected_entry %}{{ url_for('users.journal', entry_id=selected_entry.id) }}{% else %}{{ url_for('users.journal') }}{% endif %}" class="h-full flex flex-col">
                {{ form.csrf_token }}
                {% if selected_entry %}
                    <input type="hidden" name="entry_id" value="{{ selected_entry.id }}">
                {% endif %}

                <div>
                    {{ form.title(class="journal-title-input w-full", placeholder="Title your journal entry...", value=selected_entry.title if selected_entry else '') }}
                    {% if form.title.errors %}
                        <div class="text-red-500 text-xs mt-1 px-4">
                            {% for error in form.title.errors %}
                                {{ error }}
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <div class="flex-grow" style="overflow: hidden;">
                    <div id="editor-container" class="h-full border rounded-md">{{ selected_entry.content|safe if selected_entry else '' }}</div>
                    {{ form.content(class="journal-content-input hidden", id="hidden-content") }}
                    {% if form.content.errors %}
                        <div class="text-red-500 text-xs mt-1 px-4">
                            {% for error in form.content.errors %}
                                {{ error }}
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <div class="journal-button-wrapper flex items-center justify-between mt-auto">
                    <button type="button" onclick="updateContentField()" class="journal-button journal-save-button text-white">Save</button>

                    {% if selected_entry %}
                        <button type="button" onclick="document.getElementById('delete-form').submit()" class="journal-button journal-delete-button text-white">
                            Delete
                        </button>
                    {% endif %}
                </div>
            </form>

            {% if selected_entry %}
                <form id="delete-form" method="POST" action="{{ url_for('users.delete_entry', entry_id=selected_entry.id) }}" class="hidden" onsubmit="return confirm('Are you sure you want to delete this entry?');">
                    {{ form.csrf_token }}
                </form>
            {% endif %}
        </div>
    </div>
    <div id="floating-menu-container" style="position: fixed; bottom: 40px; right: 80px; z-index: 999;">
        <div id="floating-buttons" style="display: none; position: absolute; bottom: 90px; right: 0px;">
            <div class="flex flex-col gap-4 items-end">
                <button onclick="insertDeepThoughtPrompt()" class="rounded-full bg-indigo-600 p-2 shadow-lg hover:bg-indigo-700 transition-all flex items-center" title="Go Deeper" style="min-width: 150px;">
                    <img src="{{ url_for('static', filename='assets/mini-logo.svg') }}" alt="Go Deeper Icon" width="30" height="30">
                    <span class="text-white ml-2 font-medium">Go Deeper</span>
                </button>

                <button onclick="insertPerspectivePrompt()" class="rounded-full bg-green-600 p-2 shadow-lg hover:bg-green-700 transition-all flex items-center" title="Get Perspective" style="min-width: 150px;">
                    <img src="{{ url_for('static', filename='assets/mini-logo.svg') }}" alt="Get Perspective Icon" width="30" height="30">
                    <span class="text-white ml-2 font-medium">Get Perspective</span>
                </button>

                <button onclick="insertWhispersPrompt()" class="rounded-full bg-red-600 p-2 shadow-lg hover:bg-red-700 transition-all flex items-center" title="Get Direction" style="min-width: 150px;">
                    <img src="{{ url_for('static', filename='assets/mini-logo.svg') }}" alt="Get Direction Icon" width="30" height="30">
                    <span class="text-white ml-2 font-medium">Get Direction</span>
                </button>
            </div>
        </div>
        <button type="button" id="main-menu-button" onclick="toggleMenuDirect()" class="border-0 bg-transparent p-0 cursor-pointer" style="z-index: 1000;">
            <img src="{{ url_for('static', filename='assets/main-logo.svg') }}" alt="Logo" id="menu-icon" style="width: 80px; height: 80px; opacity: 100%; --stroke-color: #C5A880;">
        </button>
    </div>
    <style>
        .hidden {
            display: none;
        }
        .rotate {
            transform: rotate(45deg);
        }
        #floating-menu {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #floating-menu.visible {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }
        .floating-menu-button {
            transition: all 0.2s ease;
            transform: scale(0.95);
        }
        .floating-menu-button:hover {
            transform: scale(1);
        }
    </style>
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <script>
        // Set up title input focus events
        document.addEventListener('DOMContentLoaded', function() {
            const titleInput = document.querySelector('.journal-title-input');
            if (titleInput) {
                // Set initial gray border directly
                titleInput.style.setProperty('border-top', 'none', 'important');
                titleInput.style.setProperty('border-left', 'none', 'important');
                titleInput.style.setProperty('border-right', 'none', 'important');
                titleInput.style.setProperty('border-bottom', '1px solid #888888', 'important');

                titleInput.addEventListener('focus', function() {
                    this.style.setProperty('border-bottom', '1px solid #FFFFFF', 'important');
                });

                titleInput.addEventListener('blur', function() {
                    this.style.setProperty('border-bottom', '1px solid #888888', 'important');
                });
            }
        });

        let quill = null;

        function initializeQuill() {
            if (quill) {
                return; // Already initialized
            }

            try {
                quill = new Quill('#editor-container', {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            ['bold', 'italic', 'underline'],
                            [{ 'header': [false, true] }],
                            [{ 'color': ['#000000', '#C5A880'] }]
                        ],
                        keyboard: {
                            bindings: {
                                tab: false
                            }
                        }
                    },
                    placeholder: 'Start writing your thoughts here...',
                    bounds: '#editor-container'
                });

                // Force focus on editor after initialization
                setTimeout(() => {
                    quill.focus();
                }, 100);

                // Handle editor focus
                quill.on('selection-change', function(range) {
                    if (range) {
                        quill.focus();
                    }
                });

                // Handle editor clicks
                const editorContainer = document.getElementById('editor-container');
                editorContainer.addEventListener('click', function(e) {
                    if (e.target.closest('.ql-editor')) {
                        quill.focus();
                    }
                });

                // Add custom styles
                const customStyles = document.createElement('style');
                customStyles.textContent = `
                    .ql-editor {
                        font-size: 1rem;
                        min-height: 200px;
                        padding: 20px;
                    }
                    .ql-container {
                        height: 100%;
                        border: none !important;
                    }
                    .ql-toolbar {
                        position: sticky;
                        top: 0;
                        z-index: 1;
                        background: white;
                    }
                    /* Style for normal text size */
                    .ql-editor p {
                        font-size: 1rem !important;
                        line-height: 1.6 !important;
                    }
                    /* Style for header text size */
                    .ql-editor h1 {
                        font-size: 1.5rem !important;
                        font-weight: 600 !important;
                        margin-top: 0.5rem !important;
                        margin-bottom: 0.5rem !important;
                        line-height: 1.5 !important;
                    }
                    /* Override Quill's default styles */
                    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value="true"]::before {
                        content: "Big";
                        font-size: 2rem;
                    }
                    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value="false"]::before {
                        content: "Normal";
                        font-size: 1rem;
                    }
                `;
                document.head.appendChild(customStyles);

                // Make functions globally available
                window.updateContentField = function() {
                    if (!quill) return;
                    const hiddenInput = document.getElementById('hidden-content');
                    hiddenInput.value = quill.root.innerHTML;
                    hiddenInput.form.submit();
                }

                window.insertDeepThoughtPrompt = async function() {
                    if (!quill) return;
                    const range = quill.getSelection(true); // Get current cursor position or selection
                    if (!range) {
                        quill.focus(); // Focus editor if no selection
                        return;
                    }

                    // Get the text before the cursor
                    const textBeforeCursor = quill.getText(0, range.index);

                    try {
                        // Call the API to get a thought-provoking question
                        const response = await fetch(`/go-deeper?text=${encodeURIComponent(textBeforeCursor)}`);
                        const data = await response.json();

                        if (data.error) {
                            console.error('Error:', data.error);
                            return;
                        }

                        // Determine the insert index (end of current selection or cursor position)
                        const insertIndex = range.index + range.length;

                        // Check if the insertion point is at the beginning of a line
                        const isAtStartOfLine = insertIndex === 0 || quill.getText(insertIndex - 1, 1) === '\n';

                        let textToInsert = '';
                        let formatIndex = 0;
                        let finalCursorOffset = 0;

                        if (isAtStartOfLine) {
                            // Cursor is on a fresh line, insert directly
                            textToInsert = data.question;
                            formatIndex = insertIndex;
                            finalCursorOffset = data.question.length;
                        } else {
                            // Cursor is mid-line, insert on the next line
                            textToInsert = '\n' + data.question;
                            formatIndex = insertIndex + 1;
                            finalCursorOffset = 1 + data.question.length;
                        }

                        // Insert the text
                        quill.insertText(insertIndex, textToInsert);

                        // Apply the H1 format and matte gold color to the line containing the prompt
                        quill.formatLine(formatIndex, 1, 'header', 1);
                        quill.formatText(formatIndex, data.question.length, 'color', '#C5A880');

                        // Move the cursor after the prompt
                        quill.setSelection(insertIndex + finalCursorOffset, 0);
                        quill.focus(); // Ensure editor remains focused
                    } catch (error) {
                        console.error('Error getting question:', error);
                        // Fallback to hardcoded text if API fails
                        const fallbackText = 'Why do you feel this way?';
                        let textToInsert = isAtStartOfLine ? fallbackText + '\n' : '\n' + fallbackText + '\n';
                        quill.insertText(insertIndex, textToInsert);
                        quill.formatLine(insertIndex, 1, 'header', 1);
                        quill.formatText(insertIndex, fallbackText.length, 'color', '#C5A880');
                        quill.setSelection(insertIndex + textToInsert.length, 0);
                        quill.focus();
                    }
                }

                window.insertPerspectivePrompt = async function() {
                    if (!quill) return;

                    // Get the current selection or cursor position
                    const range = quill.getSelection(true);
                    if (!range) {
                        quill.focus();
                        return;
                    }

                    // Get the text for context
                    const textForPrompt = quill.getText();
                    const timestamp = new Date().getTime(); // Add timestamp to prevent caching

                    try {
                        // First, remove any existing perspective bubbles
                        const existingBubble = document.getElementById('perspective-bubble');
                        if (existingBubble) {
                            existingBubble.remove();
                        }

                        // Show loading indicator
                        const bounds = quill.getBounds(range.index);
                        const editorContainer = document.querySelector('#editor-container');
                        const editorRect = editorContainer.getBoundingClientRect();

                        // Create and position the bubble
                        const bubble = document.createElement('div');
                        bubble.id = 'perspective-bubble';
                        bubble.className = 'perspective-bubble';
                        bubble.innerHTML = '<div class="perspective-loading">Getting perspective...</div>';

                        // Position the bubble next to the cursor
                        bubble.style.position = 'absolute';
                        bubble.style.left = `${editorRect.right + 20}px`;
                        bubble.style.top = `${editorRect.top + bounds.top}px`;
                        document.body.appendChild(bubble);

                        // Call the API to get a perspective insight
                        const response = await fetch(`/get-perspective?text=${encodeURIComponent(textForPrompt)}&t=${timestamp}`);
                        const data = await response.json();

                        if (data.error) {
                            console.error('Error from /get-perspective API:', data.error);
                            bubble.innerHTML = '<div class="perspective-error">Error getting perspective</div>';
                            setTimeout(() => {
                                bubble.remove();
                            }, 3000);
                            return;
                        }

                        // Update the bubble with the perspective
                        const perspectiveText = data.perspective.trim();
                        bubble.innerHTML = `
                            <div class="perspective-content">
                                <div class="perspective-text">${perspectiveText}</div>
                                <button class="perspective-close" onclick="this.parentElement.parentElement.remove()">×</button>
                            </div>
                        `;

                        // Add event listener to close bubble when clicking outside
                        document.addEventListener('click', function closeBubble(e) {
                            if (!bubble.contains(e.target) && e.target.id !== 'perspective-bubble') {
                                bubble.remove();
                                document.removeEventListener('click', closeBubble);
                            }
                        });

                    } catch (error) {
                        console.error('Error getting or displaying perspective:', error);
                        // Remove bubble if there's an error
                        const bubble = document.getElementById('perspective-bubble');
                        if (bubble) {
                            bubble.innerHTML = '<div class="perspective-error">Error getting perspective</div>';
                            setTimeout(() => {
                                bubble.remove();
                            }, 3000);
                        }
                    }
                }

                window.insertWhispersPrompt = async function() {
                    if (!quill) return;
                    const range = quill.getSelection(true);
                    if (!range) {
                        quill.focus();
                        return;
                    }

                    // Get the text for context
                    const textForPrompt = quill.getText(); // Use full text like perspective
                    const timestamp = new Date().getTime();

                    try {
                        // Call the API to get whispers (now direction)
                        const response = await fetch(`/get-whispers?text=${encodeURIComponent(textForPrompt)}&t=${timestamp}`);
                        const data = await response.json();

                        if (data.error) {
                            console.error('Error from /get-whispers API:', data.error);
                            // Optionally, insert an error message into the editor
                            // quill.insertText(range.index + range.length, '\nError getting direction.', { 'color': '#ef4444' });
                            return;
                        }

                        const directionText = data.direction.trim(); // Use new 'direction' key

                        // Determine the insert index (end of current selection or cursor position)
                        const insertIndex = range.index + range.length;

                        // Check if the insertion point is at the beginning of a line
                        const isAtStartOfLine = insertIndex === 0 || quill.getText(insertIndex - 1, 1) === '\n';

                        let textToInsert = '';
                        let formatIndex = 0;
                        let finalCursorOffset = 0;

                        if (isAtStartOfLine) {
                            // Cursor is on a fresh line, insert directly
                            textToInsert = directionText;
                            formatIndex = insertIndex;
                            finalCursorOffset = directionText.length;
                        } else {
                            // Cursor is mid-line, insert on the next line
                            textToInsert = '\n' + directionText;
                            formatIndex = insertIndex + 1;
                            finalCursorOffset = 1 + directionText.length;
                        }

                        // Insert the text
                        quill.insertText(insertIndex, textToInsert);

                        // Apply the H1 format and matte gold color (like Go Deeper)
                        quill.formatLine(formatIndex, 1, 'header', 1); // Apply H1 format to the line
                        quill.formatText(formatIndex, directionText.length, 'color', '#C5A880'); // Apply color

                        // Move the cursor after the prompt
                        quill.setSelection(insertIndex + finalCursorOffset, 0);
                        quill.focus(); // Ensure editor remains focused

                    } catch (error) {
                        console.error('Error getting or displaying direction:', error);
                        // Optionally, insert a fallback/error message
                        // const fallbackText = 'Could not get direction at this time.';
                        // let textToInsert = isAtStartOfLine ? fallbackText + '\n' : '\n' + fallbackText + '\n';
                        // quill.insertText(insertIndex, textToInsert, { 'color': '#ef4444' });
                        // quill.setSelection(insertIndex + textToInsert.length, 0);
                        // quill.focus();
                    }
                }

                window.toggleMenuDirect = function() {
                    const buttons = document.getElementById('floating-buttons');
                    const icon = document.getElementById('menu-icon');
                    if (buttons.style.display === 'none' || buttons.style.display === '') {
                        buttons.style.display = 'block';
                        if (icon) icon.style.transform = 'rotate(45deg)';
                    } else {
                        buttons.style.display = 'none';
                        if (icon) icon.style.transform = 'rotate(0deg)';
                    }
                }

            } catch (error) {
                console.error('Failed to initialize Quill editor:', error);
            }
        }

        // Initialize on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeQuill);
        } else {
            initializeQuill();
        }

        // Re-initialize if editor container is modified
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList' && document.getElementById('editor-container')) {
                    initializeQuill();
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    </script>
</div>
{% endmacro %}
